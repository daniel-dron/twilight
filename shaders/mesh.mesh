#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_gpu_shader_int64 : enable

#include "vertex.glsl"

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;
layout( triangles, max_vertices = 64, max_primitives = 126 ) out;

struct Meshlet {
    uint vertex_offset;
    uint triangle_offset;
    uint vertex_count;
    uint triangle_count;

    float cone_apex[3];
    float cone_axis[3];
    float cone_cutoff;
};

struct Draw {
    mat4     model;
    uint64_t mesh;
    uint64_t pad;
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) readonly buffer DrawsBuffer {
    Draw draws[];
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) readonly buffer VertexBuffer {
    Vertex vertices[];
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) readonly buffer MeshletVertices {
    uint vertices[];
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) readonly buffer MeshletTriangles {
    uint8_t triangles[];
};

layout( push_constant, scalar ) uniform PushConstant {
    mat4             view;
    mat4             projection;
    vec4             camera_position;
    DrawsBuffer      draws_buffer;
    VertexBuffer     vertex_buffer;
    MeshletBuffer    meshlet_buffer;
    MeshletVertices  meshlet_vertices;
    MeshletTriangles meshlet_triangles;
    uint             meshlet_count;
}
pc;

layout( location = 0 ) out vec3 color[];

struct MeshTaskPayload {
    uint meshlet_indices[32];
    uint draw_id;
};
taskPayloadSharedEXT MeshTaskPayload payload;

void main( ) {
    uint mid = payload.meshlet_indices[gl_WorkGroupID.x];

    Meshlet meshlet = pc.meshlet_buffer.meshlets[mid];

    SetMeshOutputsEXT( meshlet.vertex_count, meshlet.triangle_count );

    Draw draw = pc.draws_buffer.draws[payload.draw_id];

    for ( uint i = gl_LocalInvocationIndex; i < meshlet.vertex_count; i += gl_WorkGroupSize.x ) {
        uint   index = pc.meshlet_vertices.vertices[meshlet.vertex_offset + i];
        Vertex v     = pc.vertex_buffer.vertices[index];
        vec4   pos   = pc.projection * pc.view * draw.model * vec4( v.vx, v.vy, v.vz, 1 );
        color[i]     = vec3( v.nx, v.ny, v.nz ) * 0.5 + 0.5;

        gl_MeshVerticesEXT[i].gl_Position = pos;
    }

    for ( uint i = gl_LocalInvocationIndex; i < meshlet.triangle_count; i += gl_WorkGroupSize.x ) {
        gl_MeshPrimitivesEXT[i].gl_PrimitiveID = int( gl_WorkGroupID.x );
        uint offset                            = meshlet.triangle_offset + i * 3;
        gl_PrimitiveTriangleIndicesEXT[i]      = uvec3(
                pc.meshlet_triangles.triangles[offset],
                pc.meshlet_triangles.triangles[offset + 1],
                pc.meshlet_triangles.triangles[offset + 2] );
    }
}