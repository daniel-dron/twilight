#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_mesh_shader : require

#include "draws.glsl"
#include "mesh.glsl"

layout( push_constant, scalar ) uniform PushConstant {
    mat4         view;
    mat4         projection;
    vec4         camera_position;
    DrawsBuffer  draws_buffer;
    MeshesBuffer meshes_buffer;
}
pc;

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;

struct MeshTaskPayload {
    uint meshlet_indices[32];
    uint draw_id;
};
taskPayloadSharedEXT MeshTaskPayload payload;

shared uint meshlet_count;

bool cone_cull( vec3 view_direction, vec3 cone_axis, float cone_cutoff, mat4 model ) {
    vec4 transformed_cone_axis = model * vec4( cone_axis, 0.0f );
    transformed_cone_axis      = normalize( transformed_cone_axis );

    float dot_product = dot( view_direction, transformed_cone_axis.xyz );
    return dot_product >= cone_cutoff;
}

void main( ) {
    Draw draw       = pc.draws_buffer.draws[gl_DrawID];
    payload.draw_id = gl_DrawID;

    Mesh mesh = pc.meshes_buffer.meshes[uint( draw.mesh )];

    uint wg = gl_WorkGroupID.x;
    uint ti = gl_LocalInvocationID.x;

    // Calculate the meshlet ID for the current invocation
    uint mid = wg * 32 + ti;

    meshlet_count = 0;
    memoryBarrier( );

    // take rounding back into acount
    if ( mid < mesh.meshlet_count ) {

        // If the meshlet isnt cone backface culled, add it to the array of meshlets to be processed by the mesh shaders
        Meshlet meshlet = mesh.meshlet_buffer.meshlets[mid];

        vec4 apex           = draw.model * vec4( meshlet.cone_apex[0], meshlet.cone_apex[1], meshlet.cone_apex[2], 1.0f );
        vec3 view_direction = normalize( pc.camera_position.xyz - apex.xyz );
        vec4 cone_axis      = vec4( meshlet.cone_axis[0], meshlet.cone_axis[1], meshlet.cone_axis[2], 1.0f );
        if ( !cone_cull( view_direction, cone_axis.xyz, meshlet.cone_cutoff, draw.model ) ) {
            uint index                     = atomicAdd( meshlet_count, 1 );
            payload.meshlet_indices[index] = mid;
        }
    }

    memoryBarrier( );

    // Emit mesh shader groups for the meshlets that passed culling
    EmitMeshTasksEXT( meshlet_count, 1, 1 );
}