#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_mesh_shader : require

#include "draws.glsl"
#include "mesh.glsl"

bool cone_cull( vec3 view_direction, vec3 cone_axis, float cone_cutoff, mat4 model ) {
    vec4 transformed_cone_axis = model * vec4( cone_axis, 0.0f );
    transformed_cone_axis      = normalize( transformed_cone_axis );

    float dot_product = dot( view_direction, transformed_cone_axis.xyz );
    return dot_product >= cone_cutoff;
}

struct DrawMeshTaskCommand {
    uint groupCountX;
    uint groupCountY;
    uint groupCountZ;
    uint draw_id;
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) buffer CommandsBuffer {
    DrawMeshTaskCommand cmds[];
};

layout( push_constant, scalar ) uniform block {
    mat4              view;
    mat4              projection;
    vec4              camera_position;
    DrawsBuffer       draws_buffer;
    MeshesBuffer      meshes_buffer;
    MeshletBuffer     meshlets_buffer;
    MeshletDataBuffer meshlets_data_buffer;
    VertexBuffer      vertex_buffer;
    CommandsBuffer    cmds_buffer;
};

struct MeshTaskPayload {
    uint meshlet_indices[32];
    uint draw_id;
};
taskPayloadSharedEXT MeshTaskPayload payload;

shared uint meshlet_count;

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;
void main( ) {
    DrawMeshTaskCommand cmd = cmds_buffer.cmds[gl_DrawID];

    Draw draw       = draws_buffer.draws[cmd.draw_id];
    payload.draw_id = cmd.draw_id;

    Mesh mesh = meshes_buffer.meshes[uint( draw.mesh )];

    uint wg = gl_WorkGroupID.x;
    uint ti = gl_LocalInvocationID.x;

    // Calculate the meshlet ID for the current invocation
    uint mid = wg * 32 + ti;

    meshlet_count = 0;
    memoryBarrier( );

    // take rounding back into acount
    if ( mid < mesh.meshlet_count ) {

        // If the meshlet isnt cone backface culled, add it to the array of meshlets to be processed by the mesh shaders
        Meshlet meshlet = meshlets_buffer.meshlets[mesh.meshlet_index + mid];

        vec4 apex           = draw.model * vec4( meshlet.cone_apex[0], meshlet.cone_apex[1], meshlet.cone_apex[2], 1.0f );
        vec3 view_direction = normalize( camera_position.xyz - apex.xyz );
        vec4 cone_axis      = vec4( meshlet.cone_axis[0], meshlet.cone_axis[1], meshlet.cone_axis[2], 1.0f );
        if ( !cone_cull( view_direction, cone_axis.xyz, meshlet.cone_cutoff, draw.model ) ) {
            uint index                     = atomicAdd( meshlet_count, 1 );
            payload.meshlet_indices[index] = mid;
        }
    }

    memoryBarrier( );

    // Emit mesh shader groups for the meshlets that passed culling
    EmitMeshTasksEXT( meshlet_count, 1, 1 );
}