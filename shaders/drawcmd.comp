#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_gpu_shader_int64 : enable

#include "draws.glsl"
#include "mesh.glsl"

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;

struct DrawMeshTaskCommand {
    uint groupCountX;
    uint groupCountY;
    uint groupCountZ;
    uint draw_id;
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) buffer CommandsBuffer {
    DrawMeshTaskCommand cmds[];
};

layout( buffer_reference, scalar, buffer_reference_align = 8 ) buffer DrawCount {
    uint count;
};

layout( push_constant, scalar ) uniform block {
    DrawsBuffer    draws_buffer;
    CommandsBuffer cmds_buffer;
    MeshesBuffer   meshes_buffer;
    uint64_t       count;
    DrawCount      draw_count_buffer;
    vec4           frustum[6];
};

void main( ) {
    uint cmd_id = gl_WorkGroupID.x * 32 + gl_LocalInvocationID.x;

    if ( cmd_id < count ) {
        Draw draw = draws_buffer.draws[cmd_id];
        Mesh mesh = meshes_buffer.meshes[uint( draw.mesh )];

        vec3  center = vec3( draw.model * vec4( mesh.center, 1.0f ) );
        float radius = mesh.radius * length( draw.model[0].xyz );

        bool visible = true;
        for ( int i = 0; i < 6; i++ ) {
            visible = visible && ( ( dot( frustum[i], vec4( center, 1.0f ) ) ) > -radius );
        }

        if ( visible ) {
            uint id = atomicAdd( draw_count_buffer.count, 1 );

            cmds_buffer.cmds[id].groupCountX = uint( mesh.meshlet_count + 31 ) / 32;
            cmds_buffer.cmds[id].groupCountY = 1;
            cmds_buffer.cmds[id].groupCountZ = 1;
            cmds_buffer.cmds[id].draw_id     = cmd_id;
        }
    }
}